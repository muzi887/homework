<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>星际求生：智械危机</title>
  <script src="phaser.js"></script>
  <style>
    body { margin: 0; background: #111; display: flex; justify-content: center; align-items: center; height: 100vh; color: white; font-family: sans-serif; }
  </style>
</head>
<body>
  <script>
    // --- 全局变量 ---
    var player;
    var platforms;
    var crystals;
    var enemies; // 敌人组
    var cursors;
    
    var score = 0;
    var scoreText;
    var hp = 3;  // 生命值
    var hpText;
    var gameOver = false;

    var config = {
      type: Phaser.AUTO,
      width: 1000,
      height: 600,
      physics: {
        default: "arcade",
        arcade: {
          gravity: { y: 300 },
          debug: false,
        },
      },
      scene: {
        preload: preload,
        create: create,
        update: update,
      },
    };

    var game = new Phaser.Game(config);

    function preload() {
      // 这里我们依然用代码生成素材，方便你直接运行
      // 实际项目中你可以替换为 load.image
    }

    function create() {
      // --- 1. 生成素材 ---
      createGraphics(this);

      // --- 2. 背景与UI ---
      this.add.image(500, 300, 'bg').setScale(2);
      
      // UI 文本
      scoreText = this.add.text(16, 16, 'SCORE: 0', { fontSize: '32px', fill: '#00ff00', fontFamily: 'Courier' });
      hpText = this.add.text(16, 50, 'HP: 3', { fontSize: '32px', fill: '#ff0000', fontFamily: 'Courier' });

      // --- 3. 物理平台 ---
      platforms = this.physics.add.staticGroup();
      platforms.create(500, 580, 'ground').setScale(20, 1).refreshBody(); // 地面
      platforms.create(200, 400, 'ground');
      platforms.create(800, 400, 'ground');
      platforms.create(500, 250, 'ground');

      // --- 4. 玩家设置 ---
      player = this.physics.add.sprite(100, 450, 'player');
      player.setBounce(0.2);
      player.setCollideWorldBounds(true);

      // --- 5. 物品与敌人 ---
      crystals = this.physics.add.group({
        key: 'crystal',
        repeat: 11,
        setXY: { x: 12, y: 0, stepX: 80 }
      });
      
      crystals.children.iterate(function (child) {
        child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));
      });

      // 创建敌人组（初始为空）
      enemies = this.physics.add.group();

      // --- 6. 碰撞逻辑 ---
      this.physics.add.collider(player, platforms);
      this.physics.add.collider(crystals, platforms);
      this.physics.add.collider(enemies, platforms); // 敌人也会踩在地上

      // 交互事件
      this.physics.add.overlap(player, crystals, collectCrystal, null, this);
      this.physics.add.collider(player, enemies, hitEnemy, null, this);

      // 输入控制
      cursors = this.input.keyboard.createCursorKeys();
    }

    function update() {
      if (gameOver) {
        return; // 游戏结束停止所有逻辑
      }

      // --- 玩家移动 ---
      if (cursors.left.isDown) {
        player.setVelocityX(-200);
      } else if (cursors.right.isDown) {
        player.setVelocityX(200);
      } else {
        player.setVelocityX(0);
      }

      if (cursors.up.isDown && player.body.touching.down) {
        player.setVelocityY(-350);
      }

      // --- 核心复杂功能：简单的 AI 追踪算法 ---
      enemies.children.iterate(function(enemy) {
        // AI 逻辑：如果玩家在敌人的左边，敌人就向左跑；反之亦然
        // 增加一个检测范围，比如距离 400 像素内才开始追
        if (Math.abs(player.x - enemy.x) < 400) {
            if (player.x < enemy.x) {
                enemy.setVelocityX(-100 - (score * 0.5)); // 分数越高，敌人越快
            } else {
                enemy.setVelocityX(100 + (score * 0.5));
            }
        } else {
            enemy.setVelocityX(0); // 太远了就发呆
        }
      });
    }

    // --- 业务逻辑函数 ---

    function collectCrystal(player, crystal) {
      crystal.disableBody(true, true);
      score += 10;
      scoreText.setText('SCORE: ' + score);

      // 刷新机制：收集完一波后
      if (crystals.countActive(true) === 0) {
        crystals.children.iterate(function (child) {
          child.enableBody(true, child.x, 0, true, true);
        });

        // **新功能**：每一波生成一个追踪机器人
        // 在远离玩家的地方生成
        var x = (player.x < 500) ? Phaser.Math.Between(600, 900) : Phaser.Math.Between(100, 400);
        var enemy = enemies.create(x, 16, 'enemy');
        enemy.setBounce(0.5);
        enemy.setCollideWorldBounds(true);
        enemy.setVelocity(Phaser.Math.Between(-100, 100), 20);
      }
    }

    function hitEnemy(player, enemy) {
      // 击退效果
      if (player.x < enemy.x) {
          player.x -= 30;
      } else {
          player.x += 30;
      }
      player.setVelocityY(-200);

      // 暂时禁用这个敌人的碰撞，防止瞬间扣光血（无敌帧的简化版）
      enemy.disableBody(true, true);
      // 1秒后敌人复活/重新出现
      this.time.delayedCall(1000, function() {
         enemy.enableBody(true, enemy.x, 0, true, true);
      }, [], this);

      // 扣血逻辑
      hp -= 1;
      hpText.setText('HP: ' + hp);

      // 变色示警
      player.setTint(0xff0000);
      this.time.delayedCall(200, function() {
          player.clearTint();
      });

      if (hp <= 0) {
        this.physics.pause(); // 暂停物理引擎
        player.setTint(0xff0000);
        gameOver = true;
        this.add.text(300, 250, 'GAME OVER', { fontSize: '64px', fill: '#fff', backgroundColor: '#000' });
        this.add.text(350, 320, 'Press F5 to Restart', { fontSize: '24px', fill: '#fff' });
      }
    }

    // --- 自动绘图工具 (无需手动找素材) ---
    function createGraphics(scene) {
      var g = scene.make.graphics({x:0, y:0, add:false});

      // 背景
      g.fillStyle(0x000033, 1);
      g.fillRect(0,0,32,32);
      g.generateTexture('bg', 32, 32);

      // 地面
      g.clear();
      g.fillStyle(0x444444, 1);
      g.fillRect(0,0,32,32);
      g.lineStyle(2, 0x00ff00, 1); // 绿色边框
      g.strokeRect(0,0,32,32);
      g.generateTexture('ground', 32, 32);

      // 玩家 (白色方块)
      g.clear();
      g.fillStyle(0xffffff, 1);
      g.fillRect(0,0,30,30);
      g.generateTexture('player', 30, 30);

      // 晶体 (黄色圆形)
      g.clear();
      g.fillStyle(0xffff00, 1);
      g.fillCircle(10,10,10);
      g.generateTexture('crystal', 20, 20);

      // 敌人 (红色带眼睛)
      g.clear();
      g.fillStyle(0xff0000, 1);
      g.fillRect(0,0,32,32);
      g.fillStyle(0x000000, 1);
      g.fillRect(5, 5, 10, 5); // 左眼
      g.fillRect(17, 5, 10, 5); // 右眼
      g.generateTexture('enemy', 32, 32);
    }
  </script>
</body>
</html>